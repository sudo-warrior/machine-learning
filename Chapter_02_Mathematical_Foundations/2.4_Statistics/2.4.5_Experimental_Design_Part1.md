# 2.4.5 Experimental Design - Part 1

## Introduction to Experimental Design

Experimental design is the process of planning experiments to ensure that the data collected can answer research questions effectively and efficiently. Well-designed experiments allow for valid causal inferences and minimize the influence of confounding variables. This section covers the fundamental principles and basic designs used in experimental research.

## Principles of Experimental Design

### Randomization

**Randomization** involves randomly assigning experimental units to treatment groups to ensure that all groups are probabilistically similar.

Benefits of randomization:
- Balances known and unknown confounding variables
- Allows for valid statistical inference
- Reduces selection bias

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Demonstrate randomization
np.random.seed(42)
n = 100  # Number of subjects

# Subject characteristics
age = np.random.normal(40, 10, n)
gender = np.random.binomial(1, 0.5, n)  # 0 = male, 1 = female
health_score = np.random.normal(70, 15, n)

# Create a DataFrame
subjects = pd.DataFrame({
    'ID': range(1, n+1),
    'Age': age,
    'Gender': gender,
    'Health_Score': health_score
})

# Random assignment to treatment groups
subjects['Group'] = np.random.choice(['Control', 'Treatment A', 'Treatment B'], size=n)

# Check balance of covariates across groups
balance_check = subjects.groupby('Group').agg({
    'Age': ['mean', 'std'],
    'Gender': 'mean',  # Proportion of females
    'Health_Score': ['mean', 'std']
})

print("Balance check after randomization:")
print(balance_check)

# Visualize the balance
plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
for group in ['Control', 'Treatment A', 'Treatment B']:
    plt.hist(subjects[subjects['Group'] == group]['Age'], alpha=0.5, label=group)
plt.title('Age Distribution by Group')
plt.xlabel('Age')
plt.ylabel('Frequency')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(1, 3, 2)
gender_by_group = subjects.groupby('Group')['Gender'].mean()
plt.bar(gender_by_group.index, gender_by_group.values)
plt.title('Proportion of Females by Group')
plt.ylabel('Proportion')
plt.ylim(0, 1)
plt.grid(True, alpha=0.3)

plt.subplot(1, 3, 3)
for group in ['Control', 'Treatment A', 'Treatment B']:
    plt.hist(subjects[subjects['Group'] == group]['Health_Score'], alpha=0.5, label=group)
plt.title('Health Score Distribution by Group')
plt.xlabel('Health Score')
plt.ylabel('Frequency')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

### Replication

**Replication** involves repeating the experiment multiple times to:
- Increase precision of estimates
- Reduce the impact of random variation
- Verify the reproducibility of results

Types of replication:
1. **Technical replication**: Repeated measurements of the same experimental unit
2. **Biological replication**: Measurements on different experimental units
3. **Study replication**: Independent repetition of the entire experiment

### Control

**Control** involves comparing the treatment group to a control group that doesn't receive the treatment.

Types of controls:
1. **Negative control**: No treatment or standard treatment
2. **Positive control**: Known effective treatment
3. **Placebo control**: Inactive treatment that mimics the actual treatment
4. **Vehicle control**: Contains everything except the active ingredient

### Blocking

**Blocking** involves grouping similar experimental units together to reduce variability.

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

# Demonstrate blocking
np.random.seed(42)
n = 100  # Number of subjects

# Subject characteristics with a strong confounder
age = np.random.normal(40, 10, n)
# Health score strongly depends on age
health_score = 50 + 0.5 * age + np.random.normal(0, 10, n)

# Create a DataFrame
subjects = pd.DataFrame({
    'ID': range(1, n+1),
    'Age': age,
    'Health_Score': health_score
})

# Create age blocks (young, middle, old)
subjects['Age_Block'] = pd.qcut(subjects['Age'], 3, labels=['Young', 'Middle', 'Old'])

# Random assignment within blocks
for block in ['Young', 'Middle', 'Old']:
    block_indices = subjects[subjects['Age_Block'] == block].index
    subjects.loc[block_indices, 'Group'] = np.random.choice(
        ['Control', 'Treatment'], 
        size=len(block_indices),
        p=[0.5, 0.5]  # Equal probability
    )

# Check balance of age across groups
balance_check = subjects.groupby(['Age_Block', 'Group']).agg({
    'Age': ['count', 'mean', 'std'],
    'Health_Score': ['mean', 'std']
})

print("Balance check after blocked randomization:")
print(balance_check)

# Visualize the blocking effect
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.scatter(subjects['Age'], subjects['Health_Score'], c=subjects['Group'].map({'Control': 'blue', 'Treatment': 'red'}),
           alpha=0.7)
plt.title('Age vs. Health Score (Colored by Group)')
plt.xlabel('Age')
plt.ylabel('Health Score')
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
for block in ['Young', 'Middle', 'Old']:
    for group in ['Control', 'Treatment']:
        subset = subjects[(subjects['Age_Block'] == block) & (subjects['Group'] == group)]
        label = f"{block} - {group}"
        plt.scatter(subset['Age'], subset['Health_Score'], label=label, alpha=0.7)
plt.title('Age vs. Health Score (Blocked Assignment)')
plt.xlabel('Age')
plt.ylabel('Health Score')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Basic Experimental Designs

### Completely Randomized Design

In a **completely randomized design**, experimental units are randomly assigned to treatment groups without any restrictions.

Advantages:
- Simple to implement and analyze
- Requires minimal assumptions

Disadvantages:
- May result in imbalanced groups by chance
- Less efficient when there are known sources of variation

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

# Simulate a completely randomized experiment
np.random.seed(42)
n = 60  # Number of subjects

# Random assignment to three treatment groups
groups = np.repeat(['Control', 'Treatment A', 'Treatment B'], n // 3)

# True treatment effects
effect_A = 5
effect_B = 10

# Generate outcomes with individual variation
baseline = np.random.normal(50, 10, n)  # Baseline values
outcome = baseline.copy()

# Apply treatment effects
outcome[groups == 'Treatment A'] += effect_A + np.random.normal(0, 5, sum(groups == 'Treatment A'))
outcome[groups == 'Treatment B'] += effect_B + np.random.normal(0, 5, sum(groups == 'Treatment B'))

# Create a DataFrame
experiment = pd.DataFrame({
    'Group': groups,
    'Baseline': baseline,
    'Outcome': outcome
})

# Analyze results
results = experiment.groupby('Group').agg({
    'Outcome': ['count', 'mean', 'std']
})
print("Experiment results:")
print(results)

# Perform ANOVA
f_stat, p_value = stats.f_oneway(
    experiment[experiment['Group'] == 'Control']['Outcome'],
    experiment[experiment['Group'] == 'Treatment A']['Outcome'],
    experiment[experiment['Group'] == 'Treatment B']['Outcome']
)
print(f"\nANOVA results: F = {f_stat:.4f}, p = {p_value:.4f}")

# Post-hoc t-tests
print("\nPost-hoc t-tests:")
for group1 in ['Control', 'Treatment A', 'Treatment B']:
    for group2 in ['Control', 'Treatment A', 'Treatment B']:
        if group1 < group2:  # Avoid duplicate comparisons
            t_stat, p_value = stats.ttest_ind(
                experiment[experiment['Group'] == group1]['Outcome'],
                experiment[experiment['Group'] == group2]['Outcome']
            )
            print(f"{group1} vs {group2}: t = {t_stat:.4f}, p = {p_value:.4f}")

# Visualize the results
plt.figure(figsize=(10, 6))
plt.boxplot([experiment[experiment['Group'] == g]['Outcome'] for g in ['Control', 'Treatment A', 'Treatment B']],
           labels=['Control', 'Treatment A', 'Treatment B'])
plt.title('Treatment Effects in a Completely Randomized Design')
plt.ylabel('Outcome')
plt.grid(True, alpha=0.3)
plt.show()
```

### Randomized Block Design

In a **randomized block design**, experimental units are first grouped into blocks based on a relevant characteristic, then randomly assigned to treatments within each block.

Advantages:
- Reduces variability by accounting for known sources of variation
- More powerful than completely randomized designs when blocking is effective

Disadvantages:
- More complex to implement and analyze
- Requires knowledge of important sources of variation

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.formula.api import ols

# Simulate a randomized block experiment
np.random.seed(42)
n_per_block = 6  # Number of subjects per block
n_blocks = 10     # Number of blocks
n = n_per_block * n_blocks  # Total number of subjects

# Create blocks (e.g., different locations or time periods)
blocks = np.repeat(range(1, n_blocks + 1), n_per_block)

# Random assignment to treatments within each block
treatments = []
for _ in range(n_blocks):
    block_treatments = np.repeat(['Control', 'Treatment A', 'Treatment B'], n_per_block // 3)
    np.random.shuffle(block_treatments)  # Randomize within block
    treatments.extend(block_treatments)

# True treatment effects
effect_A = 5
effect_B = 10

# Block effects (variation between blocks)
block_effects = np.random.normal(0, 15, n_blocks)

# Generate outcomes with block and individual variation
baseline = np.random.normal(50, 5, n)  # Baseline values with less individual variation
outcome = baseline.copy()

# Apply block effects
for i, block in enumerate(range(1, n_blocks + 1)):
    outcome[blocks == block] += block_effects[i]

# Apply treatment effects
outcome[np.array(treatments) == 'Treatment A'] += effect_A + np.random.normal(0, 5, sum(np.array(treatments) == 'Treatment A'))
outcome[np.array(treatments) == 'Treatment B'] += effect_B + np.random.normal(0, 5, sum(np.array(treatments) == 'Treatment B'))

# Create a DataFrame
experiment = pd.DataFrame({
    'Block': blocks,
    'Treatment': treatments,
    'Baseline': baseline,
    'Outcome': outcome
})

# Analyze results with block effects
model = ols('Outcome ~ C(Treatment) + C(Block)', data=experiment).fit()
anova_table = sm.stats.anova_lm(model, typ=2)
print("ANOVA results with blocking:")
print(anova_table)

# Compare with analysis ignoring blocks
model_no_block = ols('Outcome ~ C(Treatment)', data=experiment).fit()
anova_table_no_block = sm.stats.anova_lm(model_no_block, typ=2)
print("\nANOVA results without blocking:")
print(anova_table_no_block)

# Visualize the results
plt.figure(figsize=(15, 6))

plt.subplot(1, 2, 1)
for i, treatment in enumerate(['Control', 'Treatment A', 'Treatment B']):
    plt.scatter(experiment[experiment['Treatment'] == treatment]['Block'], 
               experiment[experiment['Treatment'] == treatment]['Outcome'],
               label=treatment, alpha=0.7)
plt.title('Outcomes by Block and Treatment')
plt.xlabel('Block')
plt.ylabel('Outcome')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
# Adjust for block effects for visualization
adjusted_outcome = experiment['Outcome'].copy()
for block in range(1, n_blocks + 1):
    block_mean = experiment[experiment['Block'] == block]['Outcome'].mean()
    overall_mean = experiment['Outcome'].mean()
    adjusted_outcome[experiment['Block'] == block] -= (block_mean - overall_mean)

# Create boxplot of adjusted outcomes
boxplot_data = [adjusted_outcome[experiment['Treatment'] == t] for t in ['Control', 'Treatment A', 'Treatment B']]
plt.boxplot(boxplot_data, labels=['Control', 'Treatment A', 'Treatment B'])
plt.title('Treatment Effects (Adjusted for Block Effects)')
plt.ylabel('Adjusted Outcome')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Summary

Experimental design provides a framework for conducting valid and efficient experiments:

1. **Principles of Experimental Design**:
   - Randomization: Randomly assign units to treatments
   - Replication: Repeat the experiment multiple times
   - Control: Compare treatment to a control group
   - Blocking: Group similar units together

2. **Basic Experimental Designs**:
   - Completely Randomized Design: Simple random assignment
   - Randomized Block Design: Random assignment within blocks

In Part 2, we will explore more advanced experimental designs, including factorial designs, Latin square designs, and split-plot designs.

## References

1. Montgomery, D. C. (2019). Design and Analysis of Experiments (10th ed.). Wiley.
2. Kirk, R. E. (2012). Experimental Design: Procedures for the Behavioral Sciences (4th ed.). SAGE Publications.
3. Box, G. E. P., Hunter, J. S., & Hunter, W. G. (2005). Statistics for Experimenters: Design, Innovation, and Discovery (2nd ed.). Wiley-Interscience.
4. Fisher, R. A. (1935). The Design of Experiments. Oliver and Boyd.
